---
title: Don't fight your external problems, laugh at them
date: 2023-10-06
summary: Writing and testing complex logic in Elixir
categories: elixir
header:
  overlay_color: "#000"
  overlay_filter: "0.5"
  overlay_image: /images/2023-03-04-foogold.png
---

In my recent blog posts, I've primarily focused on hardcore crypto topics, which may be too specialized for a broader audience. In this post, I aim to address issues that resonate with the experiences of most software engineers and demonstrate how they can be solved when writing code with Elixir. Specifically I'll describe how to write maintainable and easy to test code which makes requests to external services.

By the end of this post, the choice of the title will become clear. So, buckle up!

## Journey begins

A contemporary web application rarely functions in isolation; in most instances, it engages in communication with other web services. Consequently, developers frequently find themselves tasked with crafting intricate logic for interacting with numerous external services.

Let's examine the following example. When it comes to synchronizing crypto transactions, such as those on the Ethereum blockchain, the simplest and least error-prone approach involves fetching each block along with its transactions individually and then checking if any of the transactions within a block belong to one of your addresses.


```elixir
def sync_transactions(block_number) do
  with {:ok, block_hash} <- fetch_block_hash(block_number),
       {:ok, block_with_transactions} <- fetch_block_with_transactions(block_hash),
       {:ok, found_transactions} <- find_transactions(block_with_transactions),
       {:ok, inserted_transactions} <- insert_transactions(found_transactions),
       {:ok, inserted_additional_data} <- insert_additional_data(found_transactions) do
     {:ok, inserted_transactions}
  else
    # handle each error separately
    {:error, :request_timeout} -> ...
    {:error, :db_error} -> ...
    ...
  end
end

# fetches block hash from a blockchain node
defp fetch_block_hash(block_number) do
  EthereumClient.fetch_block_hash(block_number)
end

# fetches block with its transactions from a blockchain node
defp fetch_block(block_hash) do
  EthereumClient.fetch_block(block_hash)
end

# finds transactions that belong to our addresses
defp find_transactions(block_with_transactions) do
  to_addresses = Enum.each(block_with_transactions["transactions"], fn transaction ->
    transaction.to_address
  end)

  found_addresses = Addresses.find_addresses(to_addresses)

  found_transactions = Enum.filter(block_with_transactions["transactions"], fn transaction ->
    transaction.to_address in found_addresses
  end)

  {:ok, transactions}
end

# insert transactions
defp insert_transactions(transactions) do
  Transactions.insert_transactions(transactions)
end
```
## The problems

In the provided example, there are several challenges:

1. Complex Logic Tracking: Understanding the sequence of steps in the code can be quite challenging, particularly when the logic is intricate and involves multiple processes. This complexity can make it difficult for anyone reading the code to follow what's happening.

2. Error Handling Complexity: Dealing with errors is not straightforward. To handle errors effectively, you need to be well-versed in all the potential error types that different functions could generate. This complexity can slow down the troubleshooting and debugging process.

3. Error Ambiguity: When various functions return the same type of error, it can be confusing to distinguish between them. This ambiguity can lead to misinterpretation of the source of errors and make it harder to find and fix issues.

4. Maintenance Difficulty: Keeping this code up-to-date is a significant challenge. If any of the functions change their structure or behavior, you have to modify the error-handling part of the code to match. This close connection between function signatures and error handling makes maintenance a demanding task.

5. Ensuring Data Consistency: A critical requirement is to execute the final two steps within the same database transaction. Failure to do so would result in data inconsistency within the database. This is vital for maintaining the integrity of the database's contents.

6. Testing Complexity: Testing this code is not straightforward, particularly when it involves numerous interactions with an external service like an Ethereum node. Coordinating and validating these interactions can be time-consuming and prone to unexpected issues, making testing a complex and resource-intensive process.

7. Unstructrured response: Using raw maps instead of structured data types like structs can introduce unpredictability, especially when dealing with external services. In the context of our example, this unpredictability becomes evident when making requests to the Ethereum node. Any alterations in the responses from the external service can lead to unexpected consequences, making it crucial to consider the reliability of the data structures used.

## Sagas to the rescue

The Saga design pattern helps keep data consistent in distributed systems when dealing with multiple small services. It's like a story with a series of steps. At each step, it updates a service and sends a message to start the next step. If something goes wrong in a step, the saga performs actions to undo what happened in previous steps.

There is a great implementation of the saga pattern in elixir - [sage](https://github.com/Nebo15/sage). Let's rewrite our initial example using it

```elixir
def sync_transactions(block_number) do
  Sage.new()
  |> Sage.run(:block_hash, &fetch_block_hash/2, &handle_and_log_block_hash_error/3)
  |> Sage.run(:block_with_transactions, &fetch_block_with_transactions/2, &handle_and_log_block_error/3)
  |> Sage.run(:found_transactions, &find_transactions/2)
  |> Sage.run(:inserted_transactions, &insert_transactions/2)
  |> Sage.run(:additional_data, &insert_additional_data/2, &handle_and_logerror/3)
  |> Sage.transaction(Repo, %{block_number: block_number})
  |> case do
    {:ok, _final_effect, %{inserted_transactions: inserted_transactions}} -> {:ok, inserted_transactions}
    error -> error
  end
end

defp fetch_block_with_transactions(_effects, %{block_number: block_number}) do
  EthereumClient.fetch_block_hash(block_number)
end

defp handle_and_log_block_hash_error(%{block_hash: block_hash}, _params) do
end

defp handle_and_log_block_hash_error(%{block_hash: block_hash}, _params) do
end
```

RELEASE_NODE

- Intro

- Describe a problems
-- Create an example that we will be refactoring

- Problems

--- Problem 1 - Typed responses - parameter
--- Problem 2 - Writing complex logic - sage
--- Problem 3 - Testing complex logic - mox

- Usage
- Conclusion

Yoy readers today I want to share some insidhts some topic. don't get me wront, I'm not showing off but I'm much smarter that you're all togather (Sveta, not me)
