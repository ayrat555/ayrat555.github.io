---
layout: post
title: Hornet
date: 2020-10-26
summary: A simple library for stress testing
categories: elixir
---

### Motivation

Stress testing is a process of deliberately putting a system under intense load to test its stability. Stress testing can validate that a system can withstand expected stress, determine its limit and check its error handling capabilities.

Recently I wanted to stress test the project I'm working on. I checked existing load/stress testing libraries in the Elixir community. I found a couple of abandoned projects and one relatively well-maintained one - [Chaperon](https://github.com/polleverywhere/chaperon).

The scenario I wanted is to stress my system with constant operations per second (o/s) rate over multiple (12-24) hours. The chaperon library provides this feature with the [SpreadAsync](https://hexdocs.pm/chaperon/Chaperon.Action.SpreadAsync.html) module. From its docs, it does exactly what I want: "Action that calls a function with a given rate over a given interval of time (ms)". But after checking its [source code](https://github.com/polleverywhere/chaperon/blob/13cc4a2d2a7baacddf20c46397064b5e42a48d97/lib/chaperon/action/spread_async.ex), I found a flaw: it schedules a new process for each execution. For example, if you want to run a function with rate 3000 o/s over 20 hours, `chaperon` will start 3000 * 60 * 60 * 20 = 216_000_000 processes. If you run multiple stress tests or a single test with high o/s rate, VM machine just fails. If it does not fail, RAM usage increases over time and it may exhaust RAM completely on your machine (I think it happens because `chaperon` stores the result of each execution).

I decided to create a new library which would handle long-running stress tests more gracefully, spawning optimal number of processes. I called this library `Hornet`. In this post I'll describe its design.

### High level design

Let's examine basic entities of the Hornet:

1. Worker - it periodically executes a given function. Usually there are several workers during a single stress test.
2. RateCounter - it periodically calculates the current rate of o/s.
2. Scheduler - it periodically checks if the current rate is equal to the required rate increasing the number of workers if it's not true.

#### Worker

Hornet accepts three required parameters:

1. `rate`(o/s)
2. `func` - anonymous function that has to be executed
3. `id` - this unique id  is used for internal process names

Initially, period of execution for a process is `process_period` (Default value is 100ms), i.e. it executes the given function every `process_period` ms . So Scheduler calculates the starting number of process using the following logic:

- `process_rate` = rate (o/s) for a single process = 1_000 ms / `process_period`
- if `process_rate` / `rate` <= 1, it means a single process can execute the given function maintaining the required rate, so Hornet starts a single process with period of 1_000 / `rate`
- if `process_rate` / `rate` > 1, it means a single proces can not maintain a given rate, so Hornet starts `rate / process_rate` workers with `proces_period` period


#### RateCounter

RateCounter keeps track of the current rate by storing  `counter`. Every worker after executing the `func` function increments this counter. Periodcally in `rate_period` ms RateCounter calculates the current rate with `counter` / `rate_period`.

#### Scheduler

Often situations may occure when it takes longer to execute the given function. For example, the function requires heavy calculation. In these situations scheduler stops the running workers and inceases `process_period` and starts new workers.












- stress testing and reason behind the library (long running)
- logic
- structure
- conclusion
